<!-- Add to the mode-tabs div in quiz.html -->
<div class="mode-tabs">
<div class="tab active" data-mode="topics">Practice by Topics</div>
<div class="tab" data-mode="levels">Practice by Levels</div>
<div class="tab" data-mode="ranked">Competitive Ranked</div>
</div>

<!-- Add this after the levels-panel div -->
<div id="ranked-panel" class="hidden">
<div class="ranked-header">
<h3>Competitive Ranked Mode</h3>
<p>Test your Python skills and climb the leaderboard!</p>
</div>

<div class="ranked-info">
<div class="ranked-stats">
<div class="stat-item">
<div class="stat-icon">üèÜ</div>
<div class="stat-info">
<div class="stat-label">Your Rank</div>
<div class="stat-value" id="ranked-points">1000</div>
</div>
</div>
<div class="stat-item">
<div class="stat-icon">üìä</div>
<div class="stat-info">
<div class="stat-label">Win Rate</div>
<div class="stat-value" id="win-rate">0%</div>
</div>
</div>
<div class="stat-item">
<div class="stat-icon">üéÆ</div>
<div class="stat-info">
<div class="stat-label">Matches</div>
<div class="stat-value" id="matches-played">0</div>
</div>
</div>
</div>

<div class="ranked-rules">
<h4>How Ranked Works:</h4>
<ul>
<li>Each match consists of 10 random questions</li>
<li>Win points for correct answers, lose points for incorrect ones</li>
<li>Your rank determines your position on the leaderboard</li>
<li>Climb the ranks to earn higher badges</li>
</ul>
</div>
</div>

<div class="ranked-actions">
<button class="action-btn start-ranked-btn">START RANKED MATCH</button>
<a href="leaderboard.html" class="action-btn view-leaderboard-btn">VIEW LEADERBOARD</a>
</div>
</div>

<!-- Add this style to the head of quiz.html -->
<style>
/* Ranked Mode Styles */
.ranked-header {
text-align: center;
margin-bottom: 20px;
}

.ranked-header h3 {
color: var(--blue);
font-size: 1.4rem;
margin-bottom: 5px;
}

.ranked-stats {
display: flex;
justify-content: space-around;
margin-bottom: 20px;
}

.stat-item {
display: flex;
align-items: center;
}

.stat-icon {
font-size: 1.8rem;
margin-right: 10px;
}

.stat-label {
font-size: 0.9rem;
color: #666;
}

.stat-value {
font-weight: 700;
font-size: 1.2rem;
}

.ranked-rules {
background: #f0f8ff;
padding: 15px;
border-radius: 10px;
margin-bottom: 20px;
}

.ranked-rules h4 {
margin-bottom: 10px;
color: var(--blue);
}

.ranked-rules ul {
padding-left: 20px;
}

.ranked-rules li {
margin-bottom: 5px;
}

.ranked-actions {
display: flex;
flex-direction: column;
gap: 10px;
}

.ranked-actions .action-btn {
text-align: center;
text-decoration: none;
}

.start-ranked-btn {
background-color: var(--blue);
box-shadow: 0 4px 0 #0e90cf;
}

.start-ranked-btn:hover {
background-color: #0e90cf;
}

.view-leaderboard-btn {
background-color: #8bc34a;
box-shadow: 0 4px 0 #689f38;
}

.view-leaderboard-btn:hover {
background-color: #689f38;
}

.rank-change {
display: flex;
align-items: center;
justify-content: center;
padding: 15px;
background: #f0f8ff;
border-radius: 10px;
margin: 15px 0;
font-weight: 700;
}

.rank-change.increase {
color: var(--correct);
}

.rank-change.decrease {
color: var(--wrong);
}

.rank-change-value {
margin: 0 5px;
font-size: 1.2rem;
}

.match-completed {
text-align: center;
padding: 20px;
background: #e8f5e9;
border-radius: 10px;
margin: 15px 0;
}

.match-result {
font-size: 1.5rem;
font-weight: 800;
margin: 10px 0;
}

.match-stats {
margin: 15px 0;
}

.match-actions {
display: flex;
justify-content: space-between;
margin-top: 15px;
}
</style>

<!-- Add this script at the end of the file (before closing body tag) -->
<script>
// Ranked Mode Implementation
let rankedSettings = null;
let rankedQuestions = [];
let rankedMatchInProgress = false;
let currentRankedQuestionIndex = 0;
let correctRankedAnswers = 0;
let rankChanges = [];

// Check if user came from leaderboard to play ranked
function checkForRankedPlay() {
const playRanked = localStorage.getItem('playRanked');
if (playRanked === 'true') {
// Clear the flag
localStorage.removeItem('playRanked');
// Switch to ranked mode
switchMode('ranked');
// Auto-start if possible
if (document.querySelector('#ranked-panel .start-ranked-btn')) {
document.querySelector('#ranked-panel .start-ranked-btn').click();
}
}
}

// Load user's ranked stats
async function loadRankedStats() {
if (!currentUser || !currentUser.id) return;

try {
const response = await fetch(`/api/user/${currentUser.id}`);
const data = await response.json();

if (data.success) {
// Update display
const user = data.user;
document.getElementById('ranked-points').textContent = user.rank || 1000;

const matches = user.ranked_matches || 0;
document.getElementById('matches-played').textContent = matches;

if (matches > 0) {
const winRate = Math.round((user.ranked_wins / matches) * 100);
document.getElementById('win-rate').textContent = `${winRate}%`;
} else {
document.getElementById('win-rate').textContent = '0%';
}
}
} catch (error) {
console.error('Error loading ranked stats:', error);
}
}

// Fetch ranked settings
async function fetchRankedSettings() {
try {
const response = await fetch('/api/ranked-settings');
const data = await response.json();

if (data.success) {
rankedSettings = data.settings;
return data.settings;
} else {
console.error('Failed to load ranked settings:', data.message);
return null;
}
} catch (error) {
console.error('Error loading ranked settings:', error);
return null;
}
}

// Start a ranked match
async function startRankedMatch() {
// Only allow if logged in
if (!currentUser || !currentUser.id) {
showNotification('Please log in to play ranked matches', 'leveldown');
return;
}

// Fetch settings if not already loaded
if (!rankedSettings) {
rankedSettings = await fetchRankedSettings();
}

// Create a mix of questions from all levels
rankedQuestions = [];
const levelIds = Object.keys(questionsByLevel);

levelIds.forEach(levelId => {
const levelQuestions = questionsByLevel[levelId];
rankedQuestions.push(...levelQuestions);
});

// Shuffle questions
rankedQuestions.sort(() => Math.random() - 0.5);

// Take the first X questions (based on settings)
const questionsPerMatch = rankedSettings?.questions_per_match || 10;
rankedQuestions = rankedQuestions.slice(0, questionsPerMatch);

// Reset match state
currentRankedQuestionIndex = 0;
correctRankedAnswers = 0;
rankChanges = [];
rankedMatchInProgress = true;

// Update UI
levelNameEl.innerHTML = 'Competitive Match <span class="level-badge">Ranked</span>';
levelDescEl.textContent = 'Earn rank points by answering questions correctly';

questionNumberEl.textContent = 1;
totalQuestionsEl.textContent = rankedQuestions.length;

// Show quiz container
selectionScreen.classList.add('hidden');
quizContainer.classList.remove('hidden');

// Load first question
loadRankedQuestion();
}

// Load ranked question
function loadRankedQuestion() {
if (currentRankedQuestionIndex >= rankedQuestions.length) {
// Match is complete
completeRankedMatch();
return;
}

const question = rankedQuestions[currentRankedQuestionIndex];
questionEl.textContent = question.question;

// Update question count
questionNumberEl.textContent = currentRankedQuestionIndex + 1;

// Update progress bar
const progress = ((currentRankedQuestionIndex) / rankedQuestions.length) * 100;
progressBarEl.style.width = `${progress}%`;

// Clear previous options
optionsEl.innerHTML = '';

// Shuffle options
const shuffledOptions = [...question.options].sort(() => Math.random() - 0.5);

// Create option buttons
shuffledOptions.forEach(option => {
const btn = document.createElement('button');
btn.className = 'option';
btn.textContent = option;
btn.dataset.answer = option;

btn.addEventListener('click', () => {
if (questionsAnswered) return;

questionsAnswered = true;

const allButtons = optionsEl.querySelectorAll('.option');
allButtons.forEach(b => b.disabled = true);

const isCorrect = option === question.answer;

if (isCorrect) {
// Correct answer
btn.classList.add('correct');
btn.innerHTML += '<span class="check">‚úì</span>';

// Update stats
correctCount++;
correctRankedAnswers++;
streak++;

// Update UI
correctCountEl.textContent = correctCount;
streakCountEl.textContent = streak;

// Submit result to server
submitRankedResult(true, question);
} else {
// Wrong answer
btn.classList.add('incorrect');

// Show correct answer
allButtons.forEach(b => {
if (b.dataset.answer === question.answer) {
b.classList.add('correct');
b.innerHTML += '<span class="check">‚úì</span>';
}
});

// Update stats
wrongCount++;
streak = 0;

// Update UI
wrongCountEl.textContent = wrongCount;
streakCountEl.textContent = streak;

// Submit result to server
submitRankedResult(false, question);
}
});

optionsEl.appendChild(btn);
});

questionsAnswered = false;
}

// Submit ranked result to server
async function submitRankedResult(correct, question) {
if (!currentUser || !currentUser.id) return;

try {
// Create a unique ID for the question
const questionId = btoa(question.question).substring(0, 20);

// Determine if this is the last question
const isLastQuestion = currentRankedQuestionIndex === rankedQuestions.length - 1;

const response = await fetch('/api/ranked-result', {
method: 'POST',
headers: {
'Content-Type': 'application/json',
},
body: JSON.stringify({
userId: currentUser.id,
correct: correct,
questionId: questionId,
matchCompleted: isLastQuestion
}),
});

const data = await response.json();

if (data.success) {
// Store rank change info
rankChanges.push({
oldRank: data.oldRank,
newRank: data.newRank,
change: data.rankChange,
isPositive: data.rankChange > 0
});

// Show rank change notification
if (data.rankChange !== 0) {
const changeType = data.rankChange > 0 ? 'increased' : 'decreased';
const changeValue = Math.abs(data.rankChange);

showNotification(`Rank ${changeType} by ${changeValue} points!`,
data.rankChange > 0 ? 'levelup' : 'leveldown');
}

// Update user object
if (currentUser) {
currentUser.rank = data.newRank;
localStorage.setItem('user', JSON.stringify(currentUser));
}
}
} catch (error) {
console.error('Error submitting ranked result:', error);
}
}

// Complete ranked match
function completeRankedMatch() {
rankedMatchInProgress = false;

// Show match summary
const matchSummary = document.createElement('div');
matchSummary.className = 'match-completed';

// Calculate win/loss
const totalQuestions = rankedQuestions.length;
const winRate = Math.round((correctRankedAnswers / totalQuestions) * 100);
const matchResult = winRate >= 50 ? 'VICTORY' : 'DEFEAT';

// Calculate total rank change
let totalRankChange = 0;
rankChanges.forEach(change => {
totalRankChange += change.change;
});

matchSummary.innerHTML = `
<h3>Match Completed</h3>
<div class="match-result" style="color: ${winRate >= 50 ? 'var(--correct)' : 'var(--wrong)'}">
${matchResult}
</div>
<div class="match-stats">
<div>Correct Answers: ${correctRankedAnswers}/${totalQuestions} (${winRate}%)</div>
<div>Rank Change: <span style="color: ${totalRankChange >= 0 ? 'var(--correct)' : 'var(--wrong)'}">
${totalRankChange >= 0 ? '+' : ''}${totalRankChange}
</span></div>
<div>Current Rank: ${currentUser ? currentUser.rank : '1000'}</div>
</div>
<div class="match-actions">
<button class="btn" id="back-to-menu-btn">Back to Menu</button>
<button class="btn blue" id="play-again-btn">Play Again</button>
<a href="leaderboard.html" class="btn">View Leaderboard</a>
</div>
`;

// Clear and add to question area
questionEl.textContent = '';
questionEl.appendChild(matchSummary);

// Clear options
optionsEl.innerHTML = '';

// Hide next button
nextBtn.style.display = 'none';

// Add event listeners
matchSummary.querySelector('#back-to-menu-btn').addEventListener('click', () => {
nextBtn.style.display = 'block';
quizContainer.classList.add('hidden');
selectionScreen.classList.remove('hidden');
loadRankedStats(); // Refresh stats
});

matchSummary.querySelector('#play-again-btn').addEventListener('click', () => {
nextBtn.style.display = 'block';
startRankedMatch();
});
}

// Extend switchMode function to handle ranked mode
const originalSwitchMode = switchMode;
switchMode = function(mode) {
selectedMode = mode;

// Update UI
modeTabs.forEach(tab => {
if (tab.dataset.mode === mode) {
tab.classList.add('active');
} else {
tab.classList.remove('active');
}
});

// Show/hide appropriate panels
if (mode === 'topics') {
topicsPanel.classList.remove('hidden');
levelsPanel.classList.add('hidden');
document.getElementById('ranked-panel').classList.add('hidden');

// Clear selected levels and ranked
document.querySelectorAll('#levels-grid .level-card').forEach(card => {
card.classList.remove('selected');
});
selectedLevels = [];
} else if (mode === 'levels') {
topicsPanel.classList.add('hidden');
levelsPanel.classList.remove('hidden');
document.getElementById('ranked-panel').classList.add('hidden');

// Clear selected topics
document.querySelectorAll('.topic-item').forEach(item => {
item.classList.remove('selected');
});
selectedTopics = [];
} else if (mode === 'ranked') {
topicsPanel.classList.add('hidden');
levelsPanel.classList.add('hidden');
document.getElementById('ranked-panel').classList.remove('hidden');

// Clear selected topics and levels
document.querySelectorAll('.topic-item').forEach(item => {
item.classList.remove('selected');
});
document.querySelectorAll('#levels-grid .level-card').forEach(card => {
card.classList.remove('selected');
});
selectedTopics = [];
selectedLevels = [];
}

updateSelectionSummary();
};

// Extend nextBtn click to handle ranked mode
const originalNextBtnClick = nextBtn.onclick;
nextBtn.onclick = function() {
if (rankedMatchInProgress) {
currentRankedQuestionIndex++;
loadRankedQuestion();
} else {
// Use original handler for non-ranked questions
currentQuestionIndex++;
loadQuestion();
}
};

// Modified initialization
document.addEventListener('DOMContentLoaded', () => {
checkLoginStatus();
initTopicSelection();
initLevelSelection();
updateSelectionSummary();
checkForRankedPlay();

// Add ranked mode button event listener
document.querySelector('.start-ranked-btn').addEventListener('click', startRankedMatch);

// Add tab event listeners
document.querySelectorAll('.tab').forEach(tab => {
if (tab.dataset.mode && !tab.hasEventListener) {
tab.addEventListener('click', () => {
switchMode(tab.dataset.mode);
});
tab.hasEventListener = true;
}
});

// Load ranked stats if available
loadRankedStats();
});
</script>
